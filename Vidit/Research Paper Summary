#add all the info that you got by reading your set of research papers. 
# Set No : ____

#CODE THAT TAKES ENCODER READINGS AS INPUTS AND GIVES PREDICTED POSITION AS OUTPUT

#!/usr/bin/env python

import rospy
import numpy as np
from sensor_msgs.msg import Imu
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Twist
from tf.transformations import euler_from_quaternion

def imu_callback(data):
    # Gyroscope data (radians/second)
    gyro_angular_velocity = data.angular_velocity.z

    # Calculate the acceleration-based orientation
    acceleration_angle = np.arctan2(data.linear_acceleration.y, data.linear_acceleration.x)

    # Combine gyroscope and accelerometer-based orientation using the complementary filter
    theta = alpha * (theta_gyro + theta) + (1 - alpha) * acceleration_angle

def encoder_callback(data):
    # Assuming encoder data contains wheel velocities
    wheel_velocities = [encoder.data for encoder in data.position]

    # Wheel velocities in m/s for each wheel
    v1, v2, v3, v4 = wheel_velocities

    # Calculate linear and angular velocities of the robot
    vx = (1 / 4) * (v1 + v2 + v3 + v4)
    vy = (1 / 4) * (v1 - v2 - v3 + v4)
    omega = (1 / (4 * wheel_base)) * (v1 - v2 + v3 - v4)

    # Update the robot's position based on its previous position and estimated velocities
    x += vx * np.cos(theta) * time_elapsed_encoder
    y += vy * np.sin(theta) * time_elapsed_encoder

    # Publish the current position
    current_position_msg = Twist()
    current_position_msg.linear.x = x
    current_position_msg.linear.y = y
    current_position_msg.angular.z = theta
    position_publisher.publish(current_position_msg)

if __name__ == '__main__':
    # ROS node initialization
    rospy.init_node('robot_position_tracker')

    # Complementary filter parameters
    alpha = 0.98  # Weight for accelerometer data (adjust as needed)

    # Wheel properties
    wheel_base = 0.2  # Distance between the wheels (adjust as needed)

    # Initial robot position and orientation
    x = 0.0
    y = 0.0
    theta = 0.0

    # Time elapsed between encoder readings (in seconds)
    time_elapsed_encoder = 0.1  # Adjust this value based on your encoder reading frequency

    # Subscribers for sensor data
    imu_subscriber = rospy.Subscriber('/imu', Imu, imu_callback)
    encoder_subscriber = rospy.Subscriber('/joint_states', JointState, encoder_callback)

    # Publisher for current position
    position_publisher = rospy.Publisher('/current_position', Twist, queue_size=10)

    rospy.spin()
